1번문제 5분 44초
5989. Count Elements With Strictly Smaller and Greater Elements

2번문제 10분
5991. Rearrange Array Elements by Sign
문제:
양수와 음수의 개수가 똑같은, 짝수길이의 정수배열 nums가 주어진다.
이걸 재배열해서 아래 조건에 따르게 만들어라.
1. 모든 연속적인 정수쌍은 반대부호를 갖고 있다.
2. 같은 부호를 가진 모든 정수의 경우, 숫자에 있는 순서는 보존된다.(in-place)
3. 재배열된 배열은 양의 정수로 시작합니다.

해결방법:
양수와 음수를 따로 따로 각각의 벡터에 넣은 다음에 그냥 꺼내면 되지 않나 하나씩?

3번문제 10분컷
5990. Find All Lonely Numbers in the Array
문제:
정수배열 nums가 주어지면, 
외로운 수 x들을 찾아라.
외로운 수란 x가 단 한번만 등장하고, x+1, x-1 또한 없는 것이다.

해결방법:

유의할점:
nums의 길이는 십만
nums[i]는 0부터 백만까지.

[61,83,92,92,42,60,16,45,32,14,40,7,10,34,62,33,65,79,7,14,85,21,36,5,99,25,0,14,52,41,40]
[83,16,45,10,65,79,85,21,36,5,99,25,0,52]
[83,,,,79,,21,,,99,25,,]

4번문제 

문제:
사람에는 두가지 타입이 있다.
좋은 사람: 항상 진실만 말한다
나쁜 사람: 거짓말을 할 수도 있고, 진실을 말 할 수도 있다.
"statements"라는 2차원 n*n배열이 주어진다. n명의 사람들이 각각 서로에 대해 진술한 내용이다.
statements[i][j] 
if 0: i 가 j한테 bad person이라고 한 것.
else if 1: i가 j한테 good person이라고 한 것
else if 2: 어떠한 발언도 하지 않음.

또한 어떠한 사람도 자기 자신한테는 진술을 하지 않는다.
즉 statements[i][i] = 2 for all 0 <= i < n

이때 GOOD이 될 수 있는 "최대 사람 수"를 구하여라.

예시:
212
122
202
해결방법:
N-Queen처럼 백트랙킹?
근데 n이 15면 좀 .. 한계가 있는디

class Solution {
public:
    //person: 몇번째 사람인지
    //type: person이 진실을 말했는지 가짜를 말했는지, 0이면 거짓, 1이면 진실
    //nowGood: 현재 좋다고 가정하는 사람의 명수
    //persontypes: 0번쨰 사람부터 n-1번째 사람까지의 타입들. 초기에는 0:bad, 1: GOOD, 2:nothing. 
    //종료조건:
    //1)persontypes이 모순되는 내용이 있으면 바로 리턴하기,
    //2)만약 person이 statements의 size와 같다면? 만약 nowGood이 maxValue보다 크다면 값을 갱신하기
    int ret = 0;
    void help(vector<vector<int>> & statements, int person, bool type, int nowGood, vector<int> persontypes){
        if(person == statements.size()){
            if(nowGood > ret)
                nowGood = ret;
            return;
        }
        
        for(int i=0; i<statements.size(); i++){
            if(i == person)continue;
            if(statements[person][i] == 0){//person이 i사람한테 bad라고 함.
                if(persontypes[person] == 0){//만약 person이 good이라면, 언제나 사실만을 말함.          
                    if(persontypes[i] == 1)
                        return;
                    persontypes[i] = 0;//i는 항상 bad가 됨.
                    
                    
                }
                else if(type == 0){//만약 person이 bad이고, 거짓말을 했을 떄
                    if(persontypes[i] == 0)
                        return;
                    persontypes[i] = 1;
                }else if(type == 1){//만약 badperson이고, 진실을 말했을 때
                    if(persontypes[i] == 1)
                        return;
                    persontypes[i] = 0;
                }
                
                    
                
            }else if(statements[person][i] == 1){//person이 i한테 good이라고 함.
                if(persontypes[person] == 0){
                    if(persontypes[i] ==0 )
                        return;
                    persontypes[i] = 1;
                }
                else if(type == 0){
                    if(persontypes[i] == 1)
                        return;
                    persontypes[i] = 0;
                }
                else if(type == 1){
                    if(persontypes[i] == 0)
                        return ;
                    persontypes[i] = 1;
                }
            }
        }
        if(persontypes[person+1] == 1)
            help(statements, person+1, 1, nowGood+1, persontypes);
        else if(persontypes[person+1] == 0){
            help(statements, person+1, 0, nowGood, persontypes);
            help(statements, person+1, 1, nowGood, persontypes);
        }
        else{//person+1이 아직 정해지지 않았을 떄
            persontypes[person+1]=1;
            help(statements, person+1, 1, nowGood+1, persontypes);//좋은 사람이고, 진실을 말했을 때
            persontypes[person+1]=0;
            help(statements, person+1, 0, nowGood, persontypes);
            help(statements, person+1, 1, nowGood, persontypes);
        }
    }
    int maximumGood(vector<vector<int>>& statements) {
        vector<int> persontype(statements.size(), 0);
        persontype[0] = 1;
        help(statements, 0, 1, 1, persontype);
        persontype[0] = 0;
        help(statements, 0, 1, 0, persontype);//진실을 말했을 수도 있고
        help(statements, 0, 0, 0, persontype);//가짜를 말했을 수도 있고
        return ret;
    }
};
