1번: Easy. 8분 30초 소요
2번: Medium. 35분 소요. 정확히 못쟀음
3번: Hard. 45분 소요.
4번: Hard

결과: 3솔
전체 1시간 30분 중 3솔까지 1시간 24분 걸림

4번 문제 풀려 했으나 시간 6분 남음
나중에 꼭 풀어볼 것.

2번은 이분 탐색을 직접 구현하다가 시간이 다 갔다.
내가 알고 있는 lower_bound를 사용 하면 된다. lower_bound 개념 다시 짚고 넘어가자
lower_bound
찾으려는 key 값보다 같거나 큰 숫자가 배열 몇 번째에서 처음 등장하는지.
Ex) 1, 2, 3, 4, 5, 6 에서 5를 lower_bound 하면 4 리턴. 6을 하면 5 리턴. 
🎈중요!
6 하면 ? 5 리턴(배열의 끝 인덱스)
7 하면 ? 6 리턴(배열의 끝 보다 오른쪽)
0 하면? 0 리턴.
여기서 집중! 1을 하면 0이 리턴된다.
그래서 끝값에 대한 처리를 신경써야 한다.

추가적으로 2번에 대한 회고!
success % now를 하면 나머지가 좀 남을 수가 있다! 그떄는 find에다가 1을 추가함으로써 해결 가능!

3번
문제 자체는 어렵지 않았다!
🧨🎃단, 문제를 똑바로 봐야한다.
문제에서는 old에 해당하는 new 값이 1:1대응이란 말이 없었는데
당연히 1:1 대응이라고 생각해서 <char, char>로 잡아버린 것이 결정적인 시간 끔의 요인이였다.
예제에도 떡 하니 두개가 된다고 써져 있었는데, 잘 보지 않은 내 잘못이었다.

이걸 떠올리는 것도 괜히 복잡하게 DP 뭐시기로 꼬여서 들어가면 큰일 날 뻔 했다.
일단 쉽게 쉽게, 주어진 조건 안에서 생각하려고 노력했기 때문에
단순히 2중 for문으로, 그리고 unordered_Set과 unordered_Map을 이용했기 때문에 통과할 수 있었다.

4번은 아직 해결중. 시간이 얼마 안남았다.
