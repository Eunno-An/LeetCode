1ì°¨ 22-06-19 Fail
íšŒê³ :
1) ì²˜ìŒ DPë¬¸ì œë¼ëŠ” ê²ƒì„ ì¸ì§€-> ë¸Œë£¨íŠ¸í¬ìŠ¤ë¡œ ê³µì£¼ê°€ ìˆëŠ” ê³³ì—ì„œë¶€í„° ì‹œì‘í•´ì„œ ì›ë˜ ê¸°ì‚¬ê°€ ìˆë˜ ê³³ê¹Œì§€ ê°€ëŠ” ì½”ë“œëŠ” ëŒ€ì¶© ì„±ê³µí–ˆìŒ
ê·¸ëŸ¬ë‚˜ ì´ê±¸ DPë¡œ í•  ë•Œ ë§ì€ ë¬¸ì œì ì´ ìˆì—ˆìŒ.
-> í•¨ìˆ˜ ë³€ìˆ˜ì— nowHealthë¼ëŠ”, í˜„ì¬ ê¸°ì‚¬ì˜ ì²´ë ¥ì„ ì €ì¥í•´ ë†“ì€ ë³€ìˆ˜ê°€ ìˆì—ˆëŠ”ë° ì´ê±¸ ì¼ë‹¨ ì–´ë–»ê²Œ ì²˜ë¦¬í•  ë°©ë²•ì„ ëª»ì°¾ìŒ.
2) ê·¸ë˜ì„œ Discussionì„ ì°¸ê³ í•˜ë‹ˆ, 
-> Recursioní’€ì´:(0,0)ì—ì„œ ë¶€í„° ì‹œì‘ 
-> Iterativeí’€ì´:(m-1, n-1)ì—ì„œ ë¶€í„° ì‹œì‘.
ì´ì—ˆìŒ.

3)Recursion í’€ì´:
-> ëª¨ë“  DP ë°°ì—´ì„ -1ë¡œ ì´ˆê¸°í™” í•œë‹¤.
-> ì¬ê·€ í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë¡œì§ìœ¼ë¡œ ì‘ë™í•œë‹¤.
  ->(0,0)ë¶€í„° ì‹œì‘í•´ì„œ ê³µì£¼ê°€ ìˆëŠ” ê³³ê¹Œì§€, ì˜¤ë¥¸ìª½ê³¼ ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ë‚´ë ¤ê°„ë‹¤. ê·¸ ë•Œ ë§ˆë‹¤ dp[i][j]ë¥¼ ê°±ì‹ í•˜ëŠ” ë°©ì‹ì´ë‹¤.
  ->í˜„ì¬ (i, j)ì—ì„œ ê³µì£¼ê°€ ìˆëŠ” ê³³ê¹Œì§€ ê°€ê¸° ìœ„í•œ ìµœì†Œ í”¼í†µì„ healthë¼ê³  í•˜ì. ì´ëŠ” rightì™€ downìœ¼ë¡œ ê°”ì„ ë•Œ ê°ê° ë¹„ìš©ì˜ ìµœì†Œì—ë‹¤ê°€
  dungeon[i][j]ë¥¼ ë¹¼ì¤€ ê²ƒì´ í•„ìš”í•œ ìµœì†Œ ë¹„ìš©ì´ ëœë‹¤.
  -> ê·¸ ì „ì—! healthê°€ INT_MAXì˜€ë‹¤ë©´? healthë¥¼ 1ë¡œ ìˆ˜ì •í•´ì•¼ í•œë‹¤. healthê°€ INT_MAXì¸ ê²½ìš°ëŠ” ê³µì£¼ì˜ ìœ„ì¹˜ë¥¼ ë§í•œë‹¤. 
  ê³µì£¼ì˜ ìœ„ì¹˜ì—ì„œ healthê°€ 1ë§Œ ìˆìœ¼ë©´ ëœë‹¤.
  ->ê·¸ë¦¬ê³ , healthì—ì„œ í˜„ì¬ dungeon[i][j]ê°’ì„ ë¹¼ì£¼ëŠ” ê²ƒì´ ìš°ë¦¬ê°€ í•„ìš”í•œ ìµœì†Œë¹„ìš©ì´ë¼ê³  í–ˆë‹¤. ê·¼ë° ì´ê²Œ ì–‘ìˆ˜ë¼ë©´? ê·¸ê²Œ ë‹µì´ ë˜ê³ ,
  ë§Œì•½ ìŒìˆ˜ë¼ë©´??
  ì˜ˆë¥¼ ë“¤ì–´, healthê°€ 5ì´ê³ , dungeon[0][0]ê°€ 7 ì´ë¼ê³  í•˜ì. ì´ë–„ -2ê°€ ë˜ëŠ”ë° ì´ˆê¸° ê¸°ì‚¬ì˜ ì²´ë ¥ì€ ë°˜ë“œì‹œ 1 ì´ìƒì´ì—¬ì•¼ í•œë‹¤.
  ê·¸ë˜ì„œ ë§ˆì§€ë§‰ì— ì´ê²Œ ìŒìˆ˜ë¼ë©´ 1ë¡œ ì¡°ì •í•˜ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤. 
  (0, 0)ë¿ë§Œì´ ì•„ë‹ˆë¼ ê° (i, j)ì—ì„œë„ í•´ë‹¹ëœë‹¤.
  
  ê·¼ë° ì˜ë¬¸ì ì´ ë“¤ì€ê²Œ..
  ì™œ health - dungeon[i][j]ê°€ ìŒìˆ˜ë©´ 1ë¡œ ì„¤ì •í• ê¹Œ?
  ë‹µì€ ì‰½ë‹¤! ì™œëƒí•˜ë©´ ì–´ë–¤ ê²½ë¡œê°€ ì–‘ìˆ˜ë°–ì— ì—†ë‹¤ê³  ìƒê°í•´ë³´ì. ê·¸ëŸ¬ë©´ ì²´ë ¥ì•½ë§Œ ë¹¨ë‹¤ê°€ ê³µì£¼ ë§Œë‚˜ëŠ”ê±°ë‹ˆê¹Œ
  healthë¥¼ 1 ì´ìƒ ì„¤ì •í•  í•„ìš”ê°€ ì—†ë‹¤.
  ë¬´ìŠ¨ë§ì´ëƒ, í˜„ì¬ì˜ healthë³´ë‹¤ dungeon[i][j] ê°€ ë” í¬ë©´? (i, j)ë¶€í„° ê³µì£¼ê¹Œì§€ ê°ˆë•ŒëŠ” ì„±ê³µì„ ë³´ì¥í•œë‹¤ëŠ” ì–˜ê¸°ë‹ˆê¹Œ,
  (i, j)ë¥¼ ë„ì°©í–ˆì„ ë•ŒëŠ” ê¸°ì‚¬ê°€ ì£½ê¸° ì§ì „ì´ì–´ë„ ìƒê´€ì—†ë‹¤ëŠ” ì–˜ê¸°ê² ë‹¤!

  
4)Recursive + DP í’€ì´:
Cache[i][j] = (i, j)ë¶€í„° ê³µì£¼ì˜ ìœ„ì¹˜ê¹Œì§€ ê°€ëŠ”ë° í•„ìš”í•œ ê¸°ì‚¬ì˜ ìµœì†Œ í”¼í†µ.

5)Iteration í’€ì´:
ì €ê±° í’€ì–´ì„œ ì“´ê±´ë°, ì¢‹ì€ Discussionì—ì„œ í’€ì´ë¥¼ ê°€ì ¸ì™”ë‹¤.
dungeon[i][j]ì˜ ê°’ì„ ë°”ë¡œë°”ë¡œ ìˆ˜ì •í•˜ëŠ” ë°©ì‹.

ğŸˆì˜ë¬¸ì 
ì™œ ë§ˆì§€ë§‰ì— abs, ì ˆëŒ“ê°’ì„ ì”Œì›Œì¤„ê¹Œ?
ì´ëŠ” https://leetcode.com/problems/dungeon-game/discuss/1498636/C%2B%2B-solution-with-image-explaination ì—¬ê¸°ë¥¼ ì°¸ê³ í•˜ë©´ ëœë‹¤.
ë§Œì•½ (0, 0)ê¹Œì§€ ì™”ì„ ë•Œ, dungeon[i][j] = -10ì´ë¼ê³  í•´ë³´ì.
ì–˜ëŠ” ê³µì£¼ êµ¬í• ë ¤ê³  10ë§Œí¼ ì†Œëª¨í•œ ê²ƒì´ë‹¤.
ê·¸ë ‡ë‹¤ë©´ ë§ˆì§€ë§‰ì—ëŠ” 10 + 1ì´ ìˆì–´ì•¼ ê² ì§€.

/*
    
    // RECURSIVE APPROACH
class Solution {
public:
    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){
        if(i>=m || j>=n) return INT_MAX;
        int right=helper(i,j+1,m,n,dungeon);
        int down=helper(i+1,j,m,n,dungeon);
        int health=min(right,down);
        if(health==INT_MAX){
            health=1;
        }
        
        int res=0;
        if(health-dungeon[i][j]>0){
            res=health-dungeon[i][j];
        }
        else{
            res=1;
        }
        return res;
    }
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);
    }
};

// MEMOIZATION
class Solution {
public:
    int dp[201][201];
    int helper(int i,int j,int m,int n,vector<vector<int>> &dungeon){
        if(i>=m || j>=n) return INT_MAX;
        if(dp[i][j]!=-1) return dp[i][j];
        int right=helper(i,j+1,m,n,dungeon);
        int down=helper(i+1,j,m,n,dungeon);
        int health=min(right,down);
        if(health==INT_MAX){
            health=1;
        }
        
        int res=0;
        if(health-dungeon[i][j]>0){
            res=health-dungeon[i][j];
        }
        else{
            res=1;
        }
        return dp[i][j]=res;
    }
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        memset(dp,-1,sizeof(dp));
        return helper(0,0,dungeon.size(),dungeon[0].size(),dungeon);
    }
};

//Iterative
int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int n=dungeon.size(),m=dungeon[0].size();
        for(int i=n-1;i>=0;--i){
            for(int j=m-1;j>=0;--j){
                if(i==n-1 && j==m-1) dungeon[i][j]=dungeon[i][j];
                else if(i==n-1) dungeon[i][j]+=dungeon[i][j+1];
                else if(j==m-1) dungeon[i][j]+=dungeon[i+1][j];
                else dungeon[i][j]+=max(dungeon[i][j+1],dungeon[i+1][j]);
                
                if(dungeon[i][j]>0) dungeon[i][j]=0;
            }
        }
        return abs(dungeon[0][0])+1;
    }

  
